var documenterSearchIndex = {"docs":
[{"location":"climb1/#Climbing-Image-method","page":"Climbing Image Method","title":"Climbing Image method","text":"","category":"section"},{"location":"climb1/","page":"Climbing Image Method","title":"Climbing Image Method","text":"Pages = [\"climb1.md\"]","category":"page"},{"location":"climb1/","page":"Climbing Image Method","title":"Climbing Image Method","text":"Having construct a minimum energy path joining two states, we often want to find the saddle point joining them.  Here, we have implemented the climbing image method as described in E, Ren, and Vanden-Eijnden (2007).","category":"page"},{"location":"climb1/#Identify-Candidate-Saddle","page":"Climbing Image Method","title":"Identify Candidate Saddle","text":"","category":"section"},{"location":"climb1/","page":"Climbing Image Method","title":"Climbing Image Method","text":"The first step of the climbing image method is to identify a vector that points from one of the images, roughly, towards the saddle.  This can be done by:","category":"page"},{"location":"climb1/","page":"Climbing Image Method","title":"Climbing Image Method","text":"Finding the highest energy image along the string.  This is neareest the highest energy saddle.\nUsing the highest energy image along with two neighbors to construct an estimate of the vector pointing in the unstable direction of the saddle point. Or, more practically, construct a vector that is sufficiently collinear to the unstable direction.","category":"page"},{"location":"climb1/","page":"Climbing Image Method","title":"Climbing Image Method","text":"For example, for string U, the following computes this vector, storing it in τ:","category":"page"},{"location":"climb1/","page":"Climbing Image Method","title":"Climbing Image Method","text":"max_idx = argmax(V.(U));\nτ = upwind_tangent(U[max_idx-1:max_idx+1], V)","category":"page"},{"location":"climb1/#Set-up-Climbing-Image-Solver","page":"Climbing Image Method","title":"Set up Climbing Image Solver","text":"","category":"section"},{"location":"climb1/","page":"Climbing Image Method","title":"Climbing Image Method","text":"Having identified the direction tau, we then sep the climbing image solver with","category":"page"},{"location":"climb1/","page":"Climbing Image Method","title":"Climbing Image Method","text":"    ClimbingImage","category":"page"},{"location":"climb1/#StringMethod.ClimbingImage","page":"Climbing Image Method","title":"StringMethod.ClimbingImage","text":"ClimbingImage(∇V, τ, ∇V_climb,integrate!, dist, Δt) - Set up the Climbing Image Method\n\nFields\n\n∇V   - In place gradient of the potential\nτ - Approximate tangent vector of the unstable direction\n∇V_climb- In place gradient of the potential with reflector\nintegrate! - In place integrator\nΔt    - Time step\n\n\n\n\n\n","category":"type"},{"location":"climb1/#Set-Options","page":"Climbing Image Method","title":"Set Options","text":"","category":"section"},{"location":"climb1/","page":"Climbing Image Method","title":"Climbing Image Method","text":"Analogously to the string method, we can set solver options with respect to number of iterations, toleranace, etc. with","category":"page"},{"location":"climb1/","page":"Climbing Image Method","title":"Climbing Image Method","text":"    SaddleOptions","category":"page"},{"location":"climb1/#StringMethod.SaddleOptions","page":"Climbing Image Method","title":"StringMethod.SaddleOptions","text":"SaddleOptions(;nmax = 10^3, tol = 1e-6, verbose = false, save_trajectory = true, print_iters = 10^3) - Set up climbing image method saddle point options\n\nFields\n\nnmax = 10^3 - maximum number of solver iterations\ntol = 1e-6 - stopping tolerance\nverbose = false - print diagnostic and convergence information \nsave_trajectory = true - save the entire string at each algorithmic step\nprint_iters = 10^3 - print diagonstic information at this frequency\n\n\n\n\n\n","category":"type"},{"location":"climb1/#Solve","page":"Climbing Image Method","title":"Solve","text":"","category":"section"},{"location":"climb1/","page":"Climbing Image Method","title":"Climbing Image Method","text":"Having set the desired parameters, we execute","category":"page"},{"location":"climb1/","page":"Climbing Image Method","title":"Climbing Image Method","text":"    climbing_image","category":"page"},{"location":"climb1/#StringMethod.climbing_image","page":"Climbing Image Method","title":"StringMethod.climbing_image","text":"climbing_image(u₀, C; options=SaddleOptions()): Run the climbing image method\n\nFields\n\nu₀ - Initial guess for saddle\nC - Climbing image data structure\n\nOptional Fields\n\noptions - String method options\n\n\n\n\n\n","category":"function"},{"location":"climb1/#Example","page":"Climbing Image Method","title":"Example","text":"","category":"section"},{"location":"climb1/","page":"Climbing Image Method","title":"Climbing Image Method","text":"using Test\nusing LinearAlgebra\nusing StringMethod\nusing TestLandscapes\nusing ForwardDiff\nusing Printf\nusing Plots\n\n# set potential and get its gradient\nV = x -> Muller(x);\n∇V = x -> ForwardDiff.gradient(V, x);\n\nU0 = linear_string([0, -0.25], [0, 1.5], 15)\n\nΔt = 1e-4;\ndist = (u, v) -> norm(u - v, 2);\npin = false;\n\nstring = SimplifiedString(∇V, stepRK4!, spline_reparametrize!, dist, pin, Δt);\nopts = StringOptions(verbose=false, save_trajectory=false)\n\n# solve\nU_trajectory = simplified_string(U0, string, options=opts);\nU=U_trajectory[end];\n\n# saddle point search\nmax_idx = argmax(V.(U));\nτ = upwind_tangent(U[max_idx-1:max_idx+1], V);\nclimb = ClimbingImage(∇V,τ, stepRK4!, 1e-4);\nopts = StringMethod.SaddleOptions(save_trajectory=false);\nu_trajectory = climbing_image(U[max_idx], climb, options=opts);\nsaddle_pt = u_trajectory[end];\n\n# visualize\nxx =LinRange(-1.5, 1.5,150);\nyy = LinRange(-0.5, 2.0,150);\nV_vals = [V([x,y]) for y in yy, x in xx];\n\nplt = contour(xx,yy,min.(V_vals,500),\nlevels = LinRange(-150,500,50),color=:viridis,colorbar_title=\"V\")\nscatter!(plt, [x_[1] for x_ in U],  \n        [x_[2] for x_ in U],color=:red, label=\"String\")\nscatter!(plt, [saddle_pt[1]], [saddle_pt[2]], \n    color=:orange, markershape=:star5, label=\"Saddle\")\nxlabel!(\"x\")\nylabel!(\"y\")","category":"page"},{"location":"string1/#String-Method","page":"String Method","title":"String Method","text":"","category":"section"},{"location":"string1/","page":"String Method","title":"String Method","text":"Pages = [\"string1.md\"]\nDepth = 4\n","category":"page"},{"location":"string1/","page":"String Method","title":"String Method","text":"Recall that in the string method, one seeks to find a mapping function","category":"page"},{"location":"string1/","page":"String Method","title":"String Method","text":"   varphi(alpha)01to mathbbR^d quad varphi(0)= x_- quad varphi(1) = x_+","category":"page"},{"location":"string1/","page":"String Method","title":"String Method","text":"where x_pm are initial and terminal points which often (but not always) correspond to local minima on the energy landscape.  While many such varphi are possible, the string method identifies a minimum energy path accomplishing this transition.  Here, we implement the (simplified and improved) string method, as described in E, Ren, and Vanden-Eijnden (2007).","category":"page"},{"location":"string1/#Initialize-String","page":"String Method","title":"Initialize String","text":"","category":"section"},{"location":"string1/","page":"String Method","title":"String Method","text":"To apply the string method, we must first initialize the string, which is to say, specifcy sequence of images joining two (approximate) minima must be given. varphi^(i), where varphi^(i) approx varphi(alpha_i).  This is anticipated to be a structure of the type Vector{Vector{Float64}} where the interior Vector{Float64} structure reflect the points residing in mathbbR^d.","category":"page"},{"location":"string1/","page":"String Method","title":"String Method","text":"A convenience function is provided that constructs a linear interpolant,","category":"page"},{"location":"string1/","page":"String Method","title":"String Method","text":"    linear_string","category":"page"},{"location":"string1/#StringMethod.linear_string","page":"String Method","title":"StringMethod.linear_string","text":"linear_string(x₀, x₁, n_images) - Construct the linear interpolant string between x₀ and x₁ with a given number of images (inclusive).\n\nFields\n\nx₀ - Initial image on the string\nx₁ - Final image on the string\nn_images - Total number of images on the string, including x₀ and x₁\n\n\n\n\n\n","category":"function"},{"location":"string1/","page":"String Method","title":"String Method","text":"An example of running such a code is:","category":"page"},{"location":"string1/","page":"String Method","title":"String Method","text":"using StringMethod\n\nx_init = [1.5, -0.5];\nx_final = [-0.5, 1.0];\nn_images = 11;\n\nU = linear_string(x_init, x_final, n_images)","category":"page"},{"location":"string1/#Construct-String-Method-Solver","page":"String Method","title":"Construct String Method Solver","text":"","category":"section"},{"location":"string1/","page":"String Method","title":"String Method","text":"There are several ingredients that go into running the string method:","category":"page"},{"location":"string1/","page":"String Method","title":"String Method","text":"Time stepping scheme and Δt, the time step\nThe reparamertization scheme\nA distance function used by the reparameterization and also for checking convergence","category":"page"},{"location":"string1/","page":"String Method","title":"String Method","text":"These are invoked with the structure:","category":"page"},{"location":"string1/","page":"String Method","title":"String Method","text":"SimplifiedString","category":"page"},{"location":"string1/#StringMethod.SimplifiedString","page":"String Method","title":"StringMethod.SimplifiedString","text":"SimplifiedString(∇V, integrate!, reparameterize!, dist, Δt) -  Set up the simplified string method data structure\n\nFields\n\n∇V   - Gradient of the potential\nintegrate! - Integrator for ẋ = - ∇V(x)\nreparameterize! - Choice of reparametrization\ndist - Distance function used in reparametrization and convergence testing\npin - Boolean for pinning the endpoints of the string\nΔt    - Time step for the integrator\n\n\n\n\n\n","category":"type"},{"location":"string1/#Time-Stepping","page":"String Method","title":"Time Stepping","text":"","category":"section"},{"location":"string1/","page":"String Method","title":"String Method","text":"Time stepping is handled by the in place integrate!(x, ∇V, Δt) which advances the ODE dotx = -nabla V(x) by time Delta t.  There are two built in options, though others can be added:","category":"page"},{"location":"string1/","page":"String Method","title":"String Method","text":"stepEuler!\nstepRK4!","category":"page"},{"location":"string1/#StringMethod.stepEuler!","page":"String Method","title":"StringMethod.stepEuler!","text":"stepEuler!(u, ∇V, Δt): Perform an in place Euler step\n\nFields\n\nu - Initial state\n∇V - Gradient of energy\nΔt - Time step\n\n\n\n\n\n","category":"function"},{"location":"string1/#StringMethod.stepRK4!","page":"String Method","title":"StringMethod.stepRK4!","text":"stepRK4!(u, ∇V, Δt): Perform an in place RK4 step\n\nFields\n\nu - Initial state\n∇V - Gradient of energy\nΔt - Time step\n\n\n\n\n\n","category":"function"},{"location":"string1/#Reparametrization-and-Distance","page":"String Method","title":"Reparametrization and Distance","text":"","category":"section"},{"location":"string1/","page":"String Method","title":"String Method","text":"The string is reparamertrized with reparameterize!(U, dist, pin).  This maps the current set of images varphi^(i)_ast to a new set varphi^(i) such that, with respect to the dist function, the images are uniformly distributed,  i.e., after the function is applied","category":"page"},{"location":"string1/","page":"String Method","title":"String Method","text":"mathrmdist(varphi^(i) varphi^(i+1)) = textConstant in i","category":"page"},{"location":"string1/","page":"String Method","title":"String Method","text":"Currently, the only version implemented makes use of cubic splines as part of the Dierckx package:","category":"page"},{"location":"string1/","page":"String Method","title":"String Method","text":"spline_reparametrize!","category":"page"},{"location":"string1/#StringMethod.spline_reparametrize!","page":"String Method","title":"StringMethod.spline_reparametrize!","text":"spline_reparametrize!(U, dist, pin) - Reparametrize a string of points with a specified distance function using cubic spline interpolation\n\n\n\n\n\n","category":"function"},{"location":"string1/","page":"String Method","title":"String Method","text":"The boolean pin argument refers to whether the initial and final images on the string should be treated as pinned (true) or not (false).","category":"page"},{"location":"string1/","page":"String Method","title":"String Method","text":"The distnace function, dist(x,y) should be suitable for the problem.","category":"page"},{"location":"string1/#Set-Solver-Options","page":"String Method","title":"Set Solver Options","text":"","category":"section"},{"location":"string1/","page":"String Method","title":"String Method","text":"In addition to the string method options, we also have the numerical options associated with the number of iterations to perform, stopping tolerance, etc.  These are set by constructing:","category":"page"},{"location":"string1/","page":"String Method","title":"String Method","text":"StringOptions","category":"page"},{"location":"string1/#StringMethod.StringOptions","page":"String Method","title":"StringMethod.StringOptions","text":"StringOptions(;nmax = 10^3, tol = 1e-6, verbose = false, save_trajectory = true, print_iters = 10^3) - Set string method solver options\n\nFields\n\nnmax = 10^3 - maximum number of solver iterations\ntol = 1e-6 - stopping tolerance\nverbose = false - print diagnostic and convergence information \nsave_trajectory = true - save the entire string at each algorithmic step\nprint_iters = 10^3 - print diagonstic information at this frequency\n\n\n\n\n\n","category":"type"},{"location":"string1/#Solve","page":"String Method","title":"Solve","text":"","category":"section"},{"location":"string1/","page":"String Method","title":"String Method","text":"Having set everything, we execute","category":"page"},{"location":"string1/","page":"String Method","title":"String Method","text":"simplified_string","category":"page"},{"location":"string1/#StringMethod.simplified_string","page":"String Method","title":"StringMethod.simplified_string","text":"simplified_string - Run the simplified string method for an energy landscape set up with the SimplifiedString data structure.  This can return the entire string evolution.\n\nFields\n\nU - Initial string\nS - Simplified string data structure\nOptional Fields\noptions - String method options\n\n\n\n\n\n","category":"function"},{"location":"string1/#Example","page":"String Method","title":"Example","text":"","category":"section"},{"location":"string1/","page":"String Method","title":"String Method","text":"The following example applies the string method to the Muller (sometimes Muller-Brown) potential, a 2D energy landscape often used to demonstrate algorithms.  Muller-Brown is coded in the TestLandscapes.jl package.","category":"page"},{"location":"string1/","page":"String Method","title":"String Method","text":"using Test\nusing LinearAlgebra\nusing StringMethod\nusing TestLandscapes\nusing ForwardDiff\nusing Printf\nusing Plots\n\n# set potential and get its gradient\nV = x -> Muller(x);\n∇V = x -> ForwardDiff.gradient(V, x);\n\nU0 = linear_string([0, -0.25], [0, 1.5], 15)\n\nΔt = 1e-4;\ndist = (u, v) -> norm(u - v, 2);\npin = false;\n\nstring = SimplifiedString(∇V, stepRK4!, spline_reparametrize!, dist, pin, Δt);\nopts = StringOptions(verbose=false, save_trajectory=true)\n\n# solve\nU_trajectory = simplified_string(U0, string, options=opts);\n\n# visualize\nxx =LinRange(-1.5, 1.5,150);\nyy = LinRange(-0.5, 2.0,150);\nV_vals = [V([x,y]) for y in yy, x in xx];\n\nanim =@animate for i in 1:10:length(U_trajectory)\n    plt = contour(xx,yy,min.(V_vals,500),\n        levels = LinRange(-150,500,50),color=:viridis,colorbar_title=\"V\")\n    scatter!(plt, [x_[1] for x_ in U_trajectory[i]],  \n        [x_[2] for x_ in U_trajectory[i]],color=:red, label=\"String\")\n    xlabel!(\"x\")\n    ylabel!(\"y\")\n\n    title!(plt, @sprintf(\"Iteration %d\", i-1))\nend\ngif(anim, fps=15)\n","category":"page"},{"location":"#StringMethod.jl-Documentation","page":"Home","title":"StringMethod.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The (simplified and improve) string method and climbing image method as formulated in  E, Ren, and Vanden-Eijnden (2007).","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This work was supported in part by the US National Science Foundation Grants DMS-1818716, DMS-2111278.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"String method for the study of rare events by E, Ren, and Vanden-Eijnden\nSimplified and improved string method for computing the minimum energy paths in barrier-crossing events by E, Ren, and Vanden-Eijnden\nA climbing image nudged elastic band method for finding saddle points and minimum energy paths by Henkelman and Uberuaga","category":"page"}]
}
